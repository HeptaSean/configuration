#
# ~/.bashrc
#

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# No bash history file:
export HISTFILE=

# No less history file, let colours through less, colour man pages:
export LESSHISTFILE="-"
export LESS="--RAW-CONTROL-CHARS"
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;34m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_us=$'\E[04;34m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_so=$'\E[33m'
export LESS_TERMCAP_se=$'\E[0m'

# Defaults and colours for grep:
export GREP_OPTIONS="--no-messages"
export GREP_COLORS="mt=07;01;33:fn=35:ln=36:bn=36:se=34"

# Standard programs:
export EDITOR="vim"
export PAGER="less"
export BROWSER="chromium"

# Bash won't get SIGWINCH if another process is in the foreground.
# Enable checkwinsize so that bash will check the terminal size when
# it regains control.
# http://cnswww.cns.cwru.edu/~chet/bash/FAQ (E11)
shopt -s checkwinsize

# Enable history appending instead of overwriting.
shopt -s histappend

# Set colorful PS1 only on colorful terminals.
# dircolors --print-database uses its own built-in database
# instead of using /etc/DIR_COLORS. Try to use the external file
# first to take advantage of user additions. Use internal bash
# globbing instead of external grep binary.
# https://wiki.archlinux.org/index.php/Color_Bash_Prompt

# sanitize TERM:
safe_term=${TERM//[^[:alnum:]]/?}
match_lhs=""

[[ -f ~/.dir_colors ]] && match_lhs="${match_lhs}$(<~/.dir_colors)"
[[ -f /etc/DIR_COLORS ]] && match_lhs="${match_lhs}$(</etc/DIR_COLORS)"
[[ -z ${match_lhs} ]] \
    && type -P dircolors >/dev/null \
    && match_lhs=$(dircolors --print-database)

if [[ $'\n'${match_lhs} == *$'\n'"TERM "${safe_term}* ]] ; then
    # we have colors :-)

    # Enable colors for ls, etc. Prefer ~/.dir_colors
    if type -P dircolors >/dev/null ; then
        if [[ -f ~/.dir_colors ]] ; then
            eval $(dircolors -b ~/.dir_colors)
        elif [[ -f /etc/DIR_COLORS ]] ; then
            eval $(dircolors -b /etc/DIR_COLORS)
        fi
    fi

    if [[ ${EUID} == 0 ]]; then
        sq_color='\[\e[1;31m\]'
        un_color='\[\e[1;31m\]'
    else
        sq_color='\[\e[1;37m\]'
        un_color='\[\e[1;36m\]'
    fi
    PS1="$sq_color\342\224\214\342\224\200[\$(ec=\$?; [[ \$ec != 0 ]] && echo \"\[\e[1;31m\]\$ec\" || echo \"\[\e[1;32m\]\$ec\")$sq_color]\342\224\200[$un_color\u\[\e[0;37m\]@\[\e[1;35m\]\h$sq_color]\342\224\200[\[\e[1;33m\]\t$sq_color]\342\224\200[\[\e[1;34m\]\w$sq_color]\n$sq_color\342\224\224\342\224\200\\\$ \[\e[0m\]"
    unset sq_color

    alias ls="ls --color=auto --classify"
    alias dir="dir --color=auto --classify"
    alias vdir="vdir --color=auto --classify"
    alias grep="grep --color=auto"
    alias dmesg="dmesg --color=auto --human"
    alias diff="colordiff"
fi

# Try to keep environment pollution down, EPA loves us.
unset safe_term match_lhs

# Try to enable "Command not found" hook ("pacman -S pkgfile" to install).
# https://wiki.archlinux.org/index.php/Bash#The_.22command_not_found.22_hook
[ -r /usr/share/doc/pkgfile/command-not-found.bash ] &&
    . /usr/share/doc/pkgfile/command-not-found.bash

# Aliases for xrandr:
alias xrandr-hdmi='xrandr --output LVDS1 --auto --output HDMI1 --auto\
    --right-of LVDS1 && eval $(cat ~/.fehbg)'
alias xrandr-vga='xrandr --output LVDS1 --auto --output VGA1 --auto\
    --right-of LVDS1 && eval $(cat ~/.fehbg)'
alias xrandr-off='xrandr --output LVDS1 --auto --output HDMI1 --off\
    --output VGA1 --off && eval $(cat ~/.fehbg)'

# Aliases for output to /tmp file:
alias startx='startx &> /tmp/startx.out'
alias eclipse='nohup ${HOME}/eclipse/eclipse &> /tmp/eclipse.out &'
alias wuala='nohup ${HOME}/wuala/wuala &> /tmp/wuala.out &'
